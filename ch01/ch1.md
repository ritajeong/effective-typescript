# 아이템1 타입스크립트와 자바스크립트의 관계 이해하기

- ts는 js의 상위집합이다  
  ts는 타입이 정의된 js의 상위집합이다

- 모든 js 프로그램이 ts라는 명제 = 참  
  그 반대는 성립하지 않음

### 타입 시스템의 목표

- 런타임에 오류를 발생시킬 코드를 미리 찾아내자
- ts는 정적 타입 시스템(js는 동적 타입 시스템)
- 그러나 타입 체커가 모든 오류를 찾아내지는 않는다.

### 예시

- capital, capitol의 예시
- 코드 ch01/01/04 ~ 08 부분

### ch01/01/09

- ts의 타입 시스템은 js의 런타임 동작을 '모델링' 한다.





# 아이템2 타입스크립트 설정 이해하기

- tsconfig.json 설정 파일
- 커맨드 라인보다 설정파일을 사용하자.

## strictNullChecks

"undefined는 객체가 아닙니다."같은 런타임 에러를 피하기 위해 체크해야한다.  
프로젝트가 거대해질수록 설정 변경은 어려워질 것이므로 가능한 한 초반에 설정하자.

ts에 strict 설정을 하면 대부분의 오류를 잡아낸다.



# 아이템 3 코드 생성과 타입이 관계없음을 이해하기

## ts 컴파일러의 역할

- 최신 ts/js를 브라우저에서 동작할 수 있도록 구버전의 js로 트랜스파일함

- 코드의 타입 오류를 체크함  
  이 두 가지가 서로 완벽히 독립적이다.  
  즉, ts가 js로 변환될 때 코드 내의 타입에는 영향을 주지 않는다.  
  또한, 그 js의 실행 시점에도 타입은 영향을 미치지 않는다.

  이 역할로 보아, ts가 수행 가능한/불가능한 일을 알 수 있음

- cf. 번역+컴파일=트랜스파일(신조어)  
  translate+comfile=tranfile  
  소스코드를 동일한 동작을 하는 다른 형태의 소스코드로 변환하는 행위.  
  결과물이 여전히 컴파일되어야하는 소스코드이기 때문에 컴파일과는 구분해서 부름

## ts의 컴파일

- 타입오류가 있는 코드도 컴파일 가능

- 런타임에는 타입체크가 불가능

- 타입연산은 런타임에 영향을 주지 않음

- 런타임 타입은 선언된 타입과 다를 수 있음

- 타입스크립트 타입으로는 함수를 오버로드 할 수 없음

- 타입스크립트 타입은 런타임 성능에 영향을 주지 않음

  

# 아이템 4 구조적 타이핑에 익숙해지기

js는 duck typing 기반 : 만약 어떤 함수의 매개변수 값이 모두 제대로 주어진다면, 그 값이 어떻게 만들어졌는지 신경쓰지 않고 사용함

# 아이템5 any 타입 지양하기

- any 타입에는 타입 안정성이 없습니다.
- any는 함수 시그니처를 무시해 버립니다.
- any타입에는 언어서비스가 적용되지 않습니다.  
  let person = { first: "George" };  
  ts 언어서비스를 통해 타입이 있는 심벌에 자동완성을 해준다.

let person: any = { first: 'George' }  
any 타입인 심벌은 자동완성으로 속성이 나타나지 않음.

### ts의 모토 : 확장가능한 js

확장의 중요한 부분은 ts경험의 핵심 요소인 언어서비스이다.

- any는 타입 설계를 감춰버립니다
- any는 타입시스템의 신뢰도를 떨어뜨립니다.

어쩔 수 없이 any를 써야만 하는 상황도 있다.  
any의 단점을 보완하는지 -> 5장